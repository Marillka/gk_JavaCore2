public interface ExampleInterface {
    // С интерфейсами работают те же штуки (внутренние, вложенные) как с классами.

//    public interface ExInt { // ВНУТРЕННИЙ интерфейс
//        public static interface ExExInt { // ВЛОЖЕННЫЙ интерфейс
//
//        }
//    }

    /* 1) В интерфейсах разумеется может быть несколько абстрактных методов. И естественно тогда, при реализации интерфейса НЕ абстрактным классом, нужно будет релизовать все эти абстрактные методы.

    2) Интерфейсы могут наследовать другие интерфейсы. То есть когда мы классом реализуем интерфейс мы его имплементируем. Если мы хотим интерфейсом наследовать другой интерфейс, мы используем EXTENDS (множественное наследование среди интерфейсов).
    public interface ExampleInterface extends Flying, Cloneable, Closeable, Serializable ..... и так далее. Когда в интерфейсе наследуются другие интерфейсы, то в таком случае когда мы реализую коренной интерфейс(ExampleInterface), то это тоже самое что если бы мы этим классом реализовали бы все интерфейсы.
     */


    // String SOME_INTERFACE_FIELD; Вроде бы как интерфейс это КОНТРАКТ только на действие, но мы можем объявить поля. Но только сразу с инициализацией(без инициализации не получится).
    String SOME_INTERFACE_FIELD = "SOME"; // ЭТА ПЕРЕМЕННАЯ НЕ ПОЛЕ, ЭТО СТАТИЧЕСКАЯ КОНСТАНТА. По умолчанию PUBLIC STATIC FINAL(такими будут все поля, создаваемые в интерфейсе). Поля интерфейса принадлежат интерфейсу, а не объектам, которые его реализуют. Как с ней быть? Как и с другой любой константой, ExampleInterface.SOME_INTERFACE_FIELD.

    // По умолчанию методы ПУБЛИЧНЫЕ и АБСТРАКТНЫЕ, но начиная в Java 8+ можно объявлять методы с реализацией, ОНИ ОБЪЯВЛЯЮТСЯ С МОДИФИКАТОРОМ DEFAULT(этот модификатор именно для методов интерфейсов). Дефолтные методы, это методы интерфейсом с реализацией, вот и все. В общем то основная ценность интерфейсов - это все таки абстрактные методы, но дефолтные тоже иногда бывают полезны. Напомню только, что в наших классах методы зачастую опираются на состояние объекта, и напомню еще раз что в интерфейса нет состояния, соответственно дефолтные метод не может опираться на состояние. То есть в дефолтные методы хорошо годятся какие нибудь утилитные методы(они сами по себе, им без разницы из какого объекта они вызваны (это не статический метод), он вызывается из объекта, но имеет сразу реализацию(то есть если надо поработать с какими то данными, то их надо получить в параметрах метода через аргументы). При этом ДЕФОЛТНЫЙ МЕТОД МОЖНО ПЕРЕОПРЕДЕЛИТЬ.
    default void doDefault() {
        System.out.println("Default");
    }

    // А еще в Java 9+ появиласть возможность объявлять статические методы в интерфейсе. Статический метод в интерфейсе ВООБЩЕ НЕ ОТЛИЧАЕТСЯ от любого статического метода в любом вообще классе.
    static void doStatic() {
        System.out.println("STATIC");
    }

    // И еще в Java 9+ появиласть возможность объявить приватный метод в интерфейсе. Методы в интерфейсы абстрактные и это полагает что они будут переопределены. А приватный метод не может быть переопределен (потому что он приватный), СООТВЕТСТВЕННО ОН С РЕАЛИЗАЦИЕЙ. Но вызвать его НЕЗЬЗЯ НИОТКУДА КРОМЕ КАК ИЗ САМОГО ИНТЕРФЕЙСА. При этом приватный метод не статический, соответственно из статики мы его не вызывем. Соответственно ПРИВАТНЫЕ МЕТОДЫ НУЖНЫ ДЛЯ ТОГО ЧТОБЫ ВЫЗВАТЬ ЕГО ИЗ ДЕФОЛТНОГО МЕТОДА.
    private void doPrivate() {
        System.out.println("PRIVATE");
    }

    /*
    У нас абстрактный класс Animal, и соответственно нельзя создать его экземпляр.
    Animal animal1 = new Animal();
    Но мы можем объявить переменную типа Animal и сказать что это будет new Animal() и поставить фигурные скобки. Что это такое? Это АНОНИМНЫЙ КЛАСС(ну тип экземпляр абстрактного класса). Но на самом деле создается экземпляр не Animal, а некоего класса который наследует Animal( при этом мы не говорим что класс такой то наследует класс такой то). Такая сокращенная запись и называется анонимный класс. Можем объявить в нем переменные и методы, но получить доступ к ним мы не сможем, кроме как через методы, которые объявлены в классе Animal.
    Animal anonAnimal new Animal() {
    private int age = 10;
    private void doSomething();
    }
     */
}
